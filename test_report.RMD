---
title: >
  Example run ofexisting GSD implementation
author: >
  GSD - Geneset distances </br>
  Annekathrin Ludt - Institute of Medical Biostatistics, Epidemiology and Informatics (IMBEI) - anneludt@uni-mainz.de</br>
  University Medical Center - Mainz (Germany)
output: 
  html_document:
    toc: true
    toc_float: true
    code_folding: show
    number_sections: true
    theme: lumen
date: "`r BiocStyle::doc_date()`"  
---

```{r setup, include=FALSE, cache=FALSE, eval = TRUE, echo = FALSE}
library(knitr)
opts_chunk$set(fig.path='./figures/',
               fig.align='center', fig.show='asis', #fig.show='hold'
               eval = TRUE,
               fig.width = 10,
               fig.height = 7,
               tidy = FALSE,
               message = FALSE,
               warning = FALSE,
               size='small',
               comment="##",
               echo=TRUE,
               results='markup',
               dev = c("png","pdf"))
options(replace.assign=TRUE,width=80)

```

```{r loadLibraries,results='hide'}
library("igraph")
library("utils")
library("DT")
library("Matrix")
library("dplyr")
library("pheatmap")
library("taxize")
library("BiocFileCache")
library("STRINGdb")
```

# First step: Read data

In the first step, we read in the data. The data is expected to be in a tab-seperated format, containing two columns: 1. a column with the name of the genesets and 2. a column with the genes contained in the geneset separated by comma.

```{r getGenes}
getGenes <- function(genesets){
  if(length(genesets) == 0){
    return(list())
  }
  genesets <- lapply(1:nrow(genesets), function(i) {
    toupper(strsplit(genesets[i, 1], " ")[[1]])
  })

  return(genesets)
}
```



```{r readData}
genesets <- utils::read.delim(
          "sample_geneset.txt",
          header = TRUE,
          as.is = TRUE,
          sep = "\t",
          quote = "",
          row.names = 1,
          check.names = FALSE
        )
DT::datatable(genesets)

geneset_names <- seq(1, length(rownames(genesets)))
genes <- getGenes(genesets)
```

# Second Step: Scoring the data

After the data has been read in, it can be scored. For this, we currently provide three scores.

```{r mmScore}
getMeetMinMatrix <- function(genesets, geneset_names){
  l <- length(genesets)
  if(l == 0){
    return(-1)
  }
  m <- Matrix::Matrix(0, l, l)

  for(i in 1:(l - 1)){
    a <- genesets[i]
    for(j in (i+1):l){
      b <- genesets[j]
      int <- length(intersect(a, b))

      m[i, j] <- m[j, i] <- 1 - (int / min(length(a), length(b)))
    }
  }

  rownames(m) <- geneset_names
  colnames(m) <- geneset_names
  return(m)
}
```

```{r kappaDistance}
calculateKappa <- function(a, b, all_genes){
  set_int <- length(intersect(a, b))
  l <- length(all_genes)

  only_a <- sum(all_genes %in% a & !all_genes %in% b)
  only_b <- sum(!all_genes %in% a & all_genes %in% b)

  background <- l - sum(only_a, only_b, set_int)

  O <- (set_int + background) / l
  E <- (set_int + only_a) * (set_int + only_b) + (only_b + background) * (only_a + background)
  E <- E / l^2

  kappa <- ((O-E) / (1-E))

  if(is.nan(kappa)){
    kappa <- 0
  }
  return(min(abs(1 - kappa), 1))
}


getKappaMatrix <- function(genesets, geneset_names){
  l <- length(genesets)
  if(l == 0){
    return(-1)
  }
  k <- Matrix::Matrix(0, l, l)
  unique_genes <- unique(unlist(genesets))

  for(i in 1:(l - 1)){
    a <- unlist(genesets[i])
    for(j in (i+1):l){
      b <- unlist(genesets[j])
      k[i, j] <- k[j, i] <- calculateKappa(a, b, unique_genes)
    }
  }
  rownames(k) <- geneset_names
  colnames(k) <- geneset_names
  return(k)
}

```

```{r scoreGenesets}
mmDist <- getMeetMinMatrix(genes, geneset_names)

kappaDist <- getKappaMatrix(genes, geneset_names)

pheatmap::pheatmap(mmDist, show_rownames = F, show_colnames = F)
pheatmap::pheatmap(kappaDist, show_rownames = F, show_colnames = F)

```

Next, we plot a graph of close genesets. 

```{r graphing}
getAdjacencyMatrix <- function(distanceMatrix, cutOff){
  l <- nrow(distanceMatrix)
  adjMat <- Matrix::Matrix(0, l, l)

  for(i in 1:l){
    edge <- which(distanceMatrix[i, ] <= cutOff)
    no_edge <- which(distanceMatrix[i, ] > cutOff)

    adjMat[i, edge] <- 1
    adjMat[i, no_edge] <- 0
  }
  rownames(adjMat) <- rownames(distanceMatrix)
  colnames(adjMat) <- colnames(distanceMatrix)
  return(adjMat)
}

buildGraph <- function(adjMatrix){
  g <- igraph::graph_from_adjacency_matrix(
    adjMatrix,
    mode = "undirected",
    add.colnames = NULL,
    add.rownames = NA
  )
  return(simplify(g))
}
```


```{r igraphMM}
adj <- getAdjacencyMatrix(mmDist, 0.3)
g <- buildGraph(adj)

plot(g, layout=layout.random, main="random")
```

```{r igraphKappa}
adj <- getAdjacencyMatrix(kappaDist, 0.3)
g <- buildGraph(adj)

plot(g,layout=layout.random, main="random")
```

# Third Step: Clustering

In the next step, we cluster the data based on the scoring.

```{r clustering}
checkInclusion <- function(seeds) {
  if(length(seeds) <= 1){
    return(seeds)
  }
  remove <- c()
  for (i in 1:(length(seeds) - 1)) {
    s1 <- seeds[[i]]
    l1 <- length(s1)
    for (j in (i + 1):length(seeds)) {
      s2 <- seeds[[j]]
      l2 <- length(s2)
      if (l1 < l2) {
        if (length(intersect(s1, s2)) == l1) {
          remove <- c(remove, i)
          break
        }
      } else{
        if (length(intersect(s2, s1)) == l2) {
          remove <- c(remove, j)
        }
      }
    }
  }
  remove <- unique(remove)
  if(length(remove) == 0){
    return(seeds)
  }else{
    return(seeds[-remove])
  }
}

seedFinding <- function(distances, simThreshold, memThreshold){
  # simthreshold: what is considered 'close' relationship
  # memthreshold: how many members of a possible seed need a close relationship for the seed to be considered
  seeds <- list()
  
  # Build matrix with xij = 1 indicating i and j are close (sim(i, j) <= simThreshold)
  reach <- apply(distances, 1, function(x) as.numeric(x <= simThreshold))
  for(i in 1:nrow(distances)){
    if(sum(reach[i,], na.rm = TRUE) >= 2){
      members <- which(reach[i, ] == 1)
      includethreshold <- (length(members)^2 - length(members)) * memThreshold
      reach_red <- reach[members, members]
      in_reach <- sum(reach_red)
      if(in_reach >= includethreshold){
        members <- c(members, i)
        seeds <- c(list(sort(unique(members))), seeds)
      }
    }
  }
  seeds <- checkInclusion(unique(seeds))
  return(seeds)
}


clustering <- function(seeds, threshold){
  if(length(seeds) <= 1){
    return(seeds)
  }
  mergeable <- rep(TRUE, length(seeds))
  while(any(mergeable)){
    index <- which(mergeable)[1]
    s1 <- seeds[[index]]
    l <- length(seeds)
    for(j in 1:length(seeds)){
      s2 <- seeds[[j]]
      int <- intersect(s1, s2)
      union <- union(s1, s2)
       if(length(int) >= (threshold * length(union))){
        remove <- list(s1, s2)
        seeds <- seeds[!(seeds %in% remove)]
        seeds <- c(list(union), seeds)
        mergeable <- mergeable[-c(index, j)]
        mergeable <- c(TRUE, mergeable)
        break
       }
    }
    if(l == length(seeds)){
      mergeable[[index]] <- FALSE
    }
    
  }
  return(seeds)
}

```

```{r mmClustering}
mmSeeds <- seedFinding(mmDist, 0.3, 0.5)
mmCluster <- clustering(mmSeeds, 0.5)
```

```{r kappaClustering}
kappaSeeds <- seedFinding(kappaDist, 0.3, 0.5)
kappaCluster <- clustering(kappaSeeds, 0.5)
```

# Fourth Step: Get the Cluster to a graph

```{r getClusterGraph}
getAdjacencyMatrixCluster <- function(cluster, l){
  adj <- Matrix::Matrix(0, l, l)
  
  for(i in cluster){
    nodes <- unlist(i)
    li <- length(nodes)
    for(j in 1:(li - 1)){
      a <- nodes[j]
      for(k in (j + 1):li){
        b <- nodes[k]
        adj[a, b] <- adj[b, a] <- 1
      }
    }
  }
  
  return(adj)
}
```

```{r mmClusterAdj}
mmClusterAdj <- getAdjacencyMatrixCluster(mmCluster, nrow(mmDist))

mmClustGraph <- buildGraph(mmClusterAdj)
plot(mmClustGraph, layout=layout.random, main="random")
```

```{r kappaClusterAdj}
kappaClusterAdj <- getAdjacencyMatrixCluster(kappaCluster, nrow(kappaDist))

kappaClustGraph <- buildGraph(kappaClusterAdj)
plot(kappaClustGraph, layout=layout.random, main="random")
```

# PPI related Content

```{r useStringdb}

getStringDB <- function(species, version, score_threshold){
  return(STRINGdb$new(version = version,
                      species = species,
                      score_threshold = score_threshold,
                      input_directory = ""))
}

getAnnotation <- function(stringdb){
  return(stringdb$get_aliases())
}

getPPI <- function(genes, string_db, anno_df){
  l <- length(genes)
  string_ids <- anno_df$STRING_id[match(genes, anno_df$alias)]
  scores <- string_db$get_interactions(string_ids)
  max <- max(scores$combined_score)
  min <- min(scores$combined_score)
  
  scores$combined_score <- (scores$combined_score - min) / (max - min)
  
  gene_names_to <- anno_df$alias[match(scores$to, anno_df$STRING_id)]
  gene_names_from <- anno_df$alias[match(scores$from, anno_df$STRING_id)]
  
  scores$to <- gene_names_to
  scores$from <- gene_names_from
  
  reverse_to <- scores$from
  reverse_from <- scores$to
  
  df <- data.frame(from = reverse_from, to = reverse_to, combined_score = scores$combined_score)
  
  scores <- rbind(scores, df)
  
  return(dplyr::distinct(scores))
}

```


```{r downloadPPI, eval = F}
getId <- function(species){
  id <- taxize::get_ids(species, db = "ncbi")
  return(id$ncbi[species])
}

needsUpdate <- function(bfc, species){
  rid <- bfcquery(bfc, species)$rid
  return(bfcneedsupdate(bfc, rid))
}

downloadPPI <- function(species, cachepath = "~/GSD", version = "11.5"){
  bfc <- BiocFileCache(cachepath, ask = FALSE)
  name_ppi <- paste("PPI_",
                    species,
                    sep = "")

  name_info <- paste("PPI_Info_",
                     species,
                     sep = "")

  if(nrow(bfcquery(bfc, name_ppi)) == 0 || needsUpdate(bfc, name_ppi)){
    species_id <- getId(species)
    url_ppi <- paste("https://stringdb-static.org/download/protein.links.v",
                     version,
                     "/",
                     species_id,
                     ".protein.links.v",
                     version,
                     ".txt.gz",
                     sep = "")

    url_info <- paste("https://stringdb-static.org/download/protein.info.v",
                      version,
                      "/",
                      species_id,
                      ".protein.info.v",
                      version,
                      ".txt.gz",
                      sep = "")

    ppi <- bfcadd(bfc, rname = name_ppi, fpath = url_ppi)
    info <- bfcadd(bfc, rname = name_info, fpath = url_info)

    #ppi <- normalizePPI(ppi, info)
    return(ppi)
  }else{
  ppi <- bfcrpath(bfc, name_ppi)
  info <- bfcrpath(bfc, name_info)

  #ppi <- normalizePPI(ppi, info)

  return(ppi)
  }
}

listPPI <- function(cachepath){
  bfc <- BiocFileCache(cachepath, ask = FALSE)
  bfc_df <- bfcinfo(bfc)

  return(bfc_df$rname)
}

normalizePPI <- function(ppi, info){
  ppi <- as.data.frame(read.delim(ppi, sep = " ", header = TRUE))
  info <- as.data.frame(read.delim(info, sep = "\t", fill = FALSE, quote = ""))

  max <- max(ppi$combined_score)
  min <- min(ppi$combined_score)
  rownames <- info$preferred_name[match(ppi$protein1, info$X.string_protein_id)]
  columnnames <- info$preferred_name[match(ppi$protein2, info$X.string_protein_id)]

  new_scores <- lapply(ppi$combined_score, function(x) ((x - min) / (max - min)))


  ppi <- as.data.frame(new_scores)
  #rownames(ppi) <- rownames
  #colnames(ppi) <- columnnames

  return(ppi)
}
```

```{r pMM_scoring}
sumInteraction <- function(x, y, ppi) {
  if (length(x) ==  0 | length(y) == 0) {
    return(0)
  } else{
    return(sum(ppi[x, y]))
  }
}

getInteractionScore <- function(a, ai, b, bi, ppi, maxInteract) {
  if(length(a) == 0 || length(b) == 0 || length(ai) == 0 || length(bi) == 0){
    return(-1)
  }
  onlya <- setdiff(ai, bi)
  onlyb <- setdiff(bi, ai)
  int <- intersect(ai, bi)

  w <- min(length(a), length(b)) / (length(a) + length(b))
  intlength <- length(intersect(a, b))
  onlyblength <- length(setdiff(b, a))

  sumInt <- sumInteraction(onlya, int, ppi)
  sumOnlyb <- sumInteraction(onlya, onlyb, ppi)

  nom <- (w * sumInt) + sumOnlyb
  denom <- maxInteract * (w * intlength + onlyblength)

  return(nom / denom)
}


pMMlocal <- function(a, ai, b, bi, alpha, ppi, maxInteract) {
  z <- min(length(a), length(b))

  factor1 <- (length(intersect(a, b))) / z
  factor2 <- (alpha / z) * getInteractionScore(a, ai, b, bi, ppi, maxInteract)

  return(min(factor1 + factor2, 1))
}


getpMMMatrix <- function(genes, ppi, geneset_names, alpha = 1){
  genes_indexed <- getGenesIndexed(genes, ppi)

  l <- length(genes)
  if(l == 0){
    return(-1)
  }
  scores <- Matrix::Matrix(0, l, l)
  maxInteract <- max(ppi)
  for (i in 1:(l - 1)) {
    a <- genes[[i]]
    ai <- genes_indexed[[i]]
    for (j in (i + 1):l) {
      b <- genes[[j]]
      bi <- genes_indexed[[j]]
      pmm <- min(
        pMMlocal(a, ai, b, bi, alpha, ppi, maxInteract),
        pMMlocal(b, bi, a, ai, alpha, ppi, maxInteract)
      )
      scores[i, j] <- scores[j, i] <- pmm
    }
  }

  rownames(scores) <- geneset_names
  colnames(scores) <- geneset_names
  return(scores)
}
```

```{r getPPI, eval = F}
string_db <- getStringDB(9606, "11.5", 0.00)

string_db
anno_df <- getAnnotation(string_db)
genes_un <- unlist(genes)

start_time <- Sys.time()
ppi_human <- getPPI(genes_un, string_db, anno_df)
end_time <- Sys.time()
end_time - start_time
```

# Session information {-}
```{r sessioninfo}
sessionInfo()
```
