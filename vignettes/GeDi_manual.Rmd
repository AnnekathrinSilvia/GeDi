---
title: >
 The `GeDi` User's Guide
author:
- name: Annekathrin Silvia Nedwed
  affiliation: 
  - Institute of Medical Biostatistics, Epidemiology and Informatics (IMBEI), Mainz
  email: anneludt@uni-mainz.de
date: "`r BiocStyle::doc_date()`"
package: "`r BiocStyle::pkg_ver('GeDi')`"
output: 
  BiocStyle::html_document:
    toc_float: true
vignette: >
  %\VignetteIndexEntry{The GeDi User's Guide}
  %\VignetteEncoding{UTF-8}  
  %\VignettePackage{GeDi}
  %\VignetteKeywords{FunctionalAnnotation, Enrichment Analysis, Distance measurements,  Exploration, Visualization, GUI}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
bibliography: GeDi.bib
---

<style type="text/css">
.smaller {
  font-size: 10px
}
</style>

**Compiled date**: `r Sys.Date()`

**Last edited**: 2023-08-25

**License**: `r packageDescription("GeDi")[["License"]]`

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  error = FALSE,
  warning = FALSE,
  eval = TRUE,
  message = FALSE,
  fig.width = 10
)
options(width = 100)
stopifnot(requireNamespace("htmltools"))
htmltools::tagList(rmarkdown::html_dependency_font_awesome())
```

<hr>

# Introduction {#introduction}

This vignette describes how to use the `r BiocStyle::Biocpkg("GeDi")` package for exploring the results of a functional annotation and enrichment analysis. 

This package provides a Shiny application which aims at facilitating the exploration and interpretation of functional annotation and enrichment analysis results. The applications aims to achieve a reasonable aggregation of the detailed and sometimes overwhelming functional annotation or enrichment analysis results. This is achieved through a combination of interactivity, visualization and reproducibility.   

In order to use `r BiocStyle::Biocpkg("GeDi")` in your workflow, the results of a functional annotation or enrichment analysis are required.  

This workflow has mainly been tested with enrichment analyses conducted on the <a href="https://doi.org/10.1038/75556">Gene Ontology</a> signature database e.g. resulting from analyses with `r BiocStyle::Biocpkg("topGO")` or `r BiocStyle::Biocpkg("clusterProfiler")`. Results containing identifiers from the <a href="https://doi.org/10.1093/nar/gkac963">KEGG</a> or <a href="https://doi.org/10.1093/nar/gkab1028">Reactome</a> database (e.g. generated using `enrichKegg` or `enrichPathway` functions from the `r BiocStyle::Biocpkg("clusterProfiler")` package) can also serve as input for `GeDi` but might need some additional data transformation in advance. Please refer to the <b>Welcome</b> panel of the application for a detailed description of the expected input data format.  

In the remainder of this vignette, we will illustrate the main features of `r BiocStyle::Biocpkg("GeDi")` on a publicly available dataset from Alasoo, et al. "Shared genetic effects on chromatin and gene expression indicate a role for enhancer priming in immune response", published in Nature Genetics, January 2018 [@Alasoo2018]
[doi:10.1038/s41588-018-0046-7](https://doi.org/10.1038/s41588-018-0046-7).

The data is made available via the `r BiocStyle::Biocpkg("macrophage")` Bioconductor package, which contains the files output from the Salmon quantification (version 0.12.0, with Gencode v29 reference), as well as the values summarized at the gene level, which we will use to exemplify.

In the `macrophage` experimental setting, the samples are available from 6 different donors, in 4 different conditions (naive, treated with Interferon gamma, with SL1344, or with a combination of Interferon gamma and SL1344).
We will restrict our attention on the comparison between Interferon gamma treated samples vs naive samples.

# Getting started {#gettingstarted}

To install this package, start R and enter:

```{r install, eval=FALSE}
if (!requireNamespace("BiocManager", quietly = TRUE)) {
  install.packages("BiocManager")
}

BiocManager::install("GeDi")
```

Once installed, the package can be loaded and attached to your current workspace as follows:

```{r loadlib, eval = TRUE}
library("GeDi")
```

With the attached package, you can simply start the application by running `GeDi()`. This will launch the application and land you on the <b>Welcome</b> page. Via the <b>Data Input</b> panel you can simply provide your data directly to the application. This will also ensure that your data is in the right input format.

```{r launchapp, eval = FALSE}
GeDi()
```

Another way to start the application is to run:

```{r launchappwithData, eval=FALSE}
GeDi(
  genesets = geneset_df,
  ppi = ppi_df
  distance_scores = distance_scores_df
)
```

where 
- `geneset_df` is a `DataFrame` of your input data and contains at least one column named Genesets containing the geneset identifiers and one column named Genes which contains a comma seperated list of genes belonging to the respective geneset
- `ppi_df` is a `DataFrame` containing protein protein interactions scores with the columns from, to and combined_score
- `distance_scores_df` is a sparse `Matrix` containing the distance scores of the genesets in your data.

All of the above shown parameters are optional as you can also upload, download and compute them directly in the app. However, some of these steps can take a considerable amount of runtime, especially if you have a large data set. So it could be beneficial, to save the intermediate steps of the app, such as the  downloaded `ppi` and computed `distance_scores` to reuse them in later instances of exploration through the app.

In this vignette, we showcase the functionality of `r BiocStyle::Biocpkg("GeDi")` using the enrichment analysis results of the `macrophage` dataset.
If you want to dive in and start playing with the app immediately, you can simply run:

```{r examplerun, eval=FALSE}
example("GeDi", ask = FALSE)
```

Otherwise, you can follow the next chunks of code to generate the required input objects, step by step. This can also be used as reference guide of the steps ideally performed before the analysis of the data with `GeDi`.

In order to use `GeDi` you will need results from a functional annotation analysis. In this vignette, we will show how to perform an enrichment analysis on differentially expressed (DE) genes of the `macrophage` dataset. 

In the first step, we will load the `macrophage` data and generate a `DESeqDataset` as the differential expression analysis will be performed with `r BiocStyle::Biocpkg("DESeq2")`.

```{r create_dds, eval=TRUE}
# Load required libraries
library("macrophage")
library("DESeq2")

# Load the example dataset "gse" from the "macrophage" package
data("gse", package = "macrophage")

# Create a DESeqDataSet object using the "gse" dataset and define the 
# experimental design.
# We use the condition as part of the experimental design, because we are 
# interested in the differentially expressed genes between treatments. We also 
# add the line to the design to account for the inherent differences between 
# the donors.
dds_macrophage <- DESeqDataSet(gse, design = ~ line + condition)

# Change the row names of the DESeqDataSet object to Ensembl IDs
rownames(dds_macrophage) <- substr(rownames(dds_macrophage), 1, 15)

# Have a look at the resulting DESeqDataSet object
dds_macrophage
```

Now that we have our `DESeqDataset`, we can perform the DE analysis. In this vignette, we will use the results of the comparison of two different conditions of the data set, namely `IFNg` and `naive`, while controlling for the cell line of origin (which has 6 levels, namely `r knitr::combine_words(levels(dds_macrophage$line))`).

Before we perform the DE analysis, we filter lowly expressed features from the data set. In this example we filter all genes that do not have at least 10 counts in at least 6 samples (where 6 is the size of the smallest group in the data).

Afterwards, we perform the DE analysis and test against a null hypothesis of a log2FoldChange of 1 in order to ensure that we call those genes with a consistent *and* robust expression change DE.

In a last step, we add the gene symbols to the resulting `DataFrame` which will later serve as our Genes column in the input data to `GeDi`.

```{r create_resde1, eval = TRUE}
# Filter genes based on read counts
# Calculate the number of genes with at least 10 counts in at least 6 samples
keep <- rowSums(counts(dds_macrophage) >= 10) >= 6

# Subset the DESeqDataSet object to keep only the selected genes
dds_macrophage <- dds_macrophage[keep, ]

# Have a look at the resulting DESeqDataSet object
dds_macrophage
```

```{r create_resde2, eval = TRUE}
# Perform differential expression analysis using DESeq2
dds_macrophage <- DESeq(dds_macrophage)

# Extract differentially expressed genes
# Perform contrast analysis comparing "IFNg" condition to "naive" condition
# Set a log2 fold change threshold of 1 and a significance level (alpha) of 0.05
res_macrophage_IFNg_vs_naive <- results(dds_macrophage,
  contrast = c("condition", "IFNg", "naive"),
  lfcThreshold = 1, alpha = 0.05
)

# Add gene symbols to the results in a column "SYMBOL"
res_macrophage_IFNg_vs_naive$SYMBOL <- rowData(dds_macrophage)$SYMBOL
```

Instead of computing the object from scratch, you can also load the precomputed object from the available data of the package.

```{r load_resde, eval=FALSE}
# Load precomputed differential expression results from the "GeDi" package
# The results are stored in the object "res_macrophage_IFNg_vs_naive"
data("res_macrophage_IFNg_vs_naive", package = "GeDi")

# Display the first few rows of the differential expression results
head(res_macrophage_IFNg_vs_naive)
```

After we performed the differential expression analysis, we can now perform the functional annotation analysis. For this purpose, we are first going to extract the DE genes from the previously generated results as well as determine the background genes to be used for the functional enrichment. 

For the enrichment analysis, we are going to use the overrepresentation analysis method implemented in the `r BiocStyle::Biocpkg("topGO")` package. In order to facilitate the later usage of these results in `GeDi`, we use the `topGOtable` wrapper function available in the `r BiocStyle::Biocpkg("pcaExplorer")`. This function uses per default the `BP` ontology and the `elim` method to decorrelate the GO graph structure and deliver less redundant functional categories and generated a `DataFrame` object that can readily be used in `GeDi`.

As previously mentioned, also enrichment results generated with `r BiocStyle::Biocpkg("clusterProfiler")` can be used. Especially results generated with the `enrichGO` method have been tested during the development of `GeDi`, but also the results form the `enrichKEGG` and `enrichPathway` method can be used as input.


```{r create_resenrich1, eval=TRUE}
# Load required packages for analysis
library("pcaExplorer")
library("GeneTonic")
library("AnnotationDbi")

# Extract gene symbols from the DESeq2 results object where FDR is below 0.05
# The function deseqresult2df is used to convert the DESeq2 results to a 
# dataframe format
# FDR is set to 0.05 to filter significant results
de_symbols_IFNg_vs_naive <- deseqresult2df(res_macrophage_IFNg_vs_naive, FDR = 0.05)$SYMBOL

# Extract gene symbols for background using the DESeq2 results object
# Filter genes that have nonzero counts
bg_ids <- rowData(dds_macrophage)$SYMBOL[rowSums(counts(dds_macrophage)) > 0]
```

```{r create_resenrich2, eval=TRUE}
# Load required package for analysis
library("topGO")

# Perform Gene Ontology enrichment analysis using the topGOtable function from 
# the "pcaExplorer" package
macrophage_topGO_example <-
  pcaExplorer::topGOtable(de_symbols_IFNg_vs_naive,
    bg_ids,
    ontology = "BP",
    mapping = "org.Hs.eg.db",
    geneID = "symbol",
    topTablerows = 500
  )
```

As previously mentioned, `Gedi` expects the input to have at least two columns, one named Genesets and one named Genes. While this is not strictly necessary if you provide your data, it is required if you want to start the application with your input as parameters (e.g. `GeDi(genesets = genesets_df)`). In this case, the Genesets column is expected to contain some form of geneset identifiers for each set of the input, while the Genes column is expected to be a comma-separated list of genes belonging to each geneset. 

Hence, we will rename the columns of the resulting `DataFrame` of the enrichment analysis to fit the required format. 
```{r renamecolumns, eval=TRUE}
# Rename columns in the macrophage_topGO_example dataframe
# Change the column name "GO.ID" to "Genesets"
names(macrophage_topGO_example)[names(macrophage_topGO_example) == "GO.ID"] <- "Genesets"

# Change the column name "genes" to "Genes"
names(macrophage_topGO_example)[names(macrophage_topGO_example) == "genes"] <- "Genes"
```
  

## All set!

Now we have generated functional annotation results form the `macrophage` dataset and can start exploring the data with `GeDi`. You can either start the application and provide the generated data using the `GeDi()` command. Or, if you followed this vignette, you can start the application directly with the loaded data by running `GeDi(genesets = macrophage_topGO_example)`.


```{r dryrun, eval=FALSE}
GeDi()

GeDi(genesets = macrophage_topGO_example)
```

# Description of the `GeDi` user interface {#userinterface}

The `GeDi` app is built with `r BiocStyle::CRANpkg("shiny")`, and its layout is built around the components of `r BiocStyle::CRANpkg("bs4Dash")`, a modern looking dashboard based on Bootstrap 4.

## Header (navbar)

The dashboard navbar (as it is called in `bs4Dash`) contains two dropdown menus, which can be expanded by clicking on the respective icons (<i class="fa fa-book"></i> and <i class="fa fa-info"></i>).
These provide additional buttons to do one the following:

- <i class="fa fa-book"></i> - inspect the `r BiocStyle::Biocpkg("GeDi")` vignette (either the one installed in bundle with the package, or the online version)
- <i class="fa fa-question-circle"></i> - read some first help information on `GeDi` (what the package does in brief, what is required to run properly)
- <i class="fa fa-info-circle"></i> - display information about the current session (via `sessionInfo()`)
- <i class="fa fa-heart"></i> - show some general information on `r BiocStyle::Biocpkg("GeDi")`, like where to find its development version (and contribute to that), or how to cite this tool.

## Sidebar

On the left side of the app, by clicking on the <i class="fa fa-bars"></i> menu bar icon (or if the app is viewed in full screen, by simply moving the mouse over to the left side), the sidebar menu is triggered.
This constitutes the main way to access the different tabs of `GeDi`, which will be explained in more detail in the next section (\@ref(functionality)).


## Body

The main body of the `GeDi` application is structured in tabs that are activated by clicking on the respective icons or text in the sidebar.

While the <b>Welcome</b> tab might be self-explanatory, the functionality of each tab can go in depth, and new users can benefit of the question circle button (<i class="fa fa-question-circle"></i>) button to trigger an interactive tour of `GeDi`, which allows users to learn the basic usage mechanisms by doing.
During a tour, the highlighted elements respond to the user's actions, while the rest of the UI is kept shaded.
Tours can be interrupted anytime by clicking outside of the focused window, and arrows (left, right) can be used as well to navigate between steps.
The tour functionality is provided by the beautiful `r BiocStyle::CRANpkg("rintrojs")` package.

# The `GeDi` functionality {#functionality}

The main `GeDi` app is structured in different panels, and each of these is presented in detail in the subsequent sections.

## The Welcome panel

This panel is intended to give an overview on how to use `GeDi`. For this purpose, the panel highlights in detail how to generate the input data for the application. It also explains the expected input format and the different interactive elements that you will find in the remaining panels of the app.  

## The Data Input panel

This panel will manage data input in case it's not provided within the function call. The panel is divided into separate boxes, each representing a distinct step of the data input process. These boxes will sequentially appear as you successfully complete each preceding step.


<b>Step 1</b>: Provide your Genesets as input data

In the first box labeled <b>Step 1</b>, you can provide your data by using the <b>Browse</b> button. Clicking this button will open a modal window that allows you to select the relevant file from your computer storage. After successfully reading the data, you can view a preview of it using the <b>Data Preview</b> box on the right. During this step, the application verifies whether your input contains the "Genesets" and "Genes" columns. If these columns are missing, a small error message will appear in the lower right corner. Also two drop-down menus will appear in the box. These enable you to select the correct columns from your data and update the the input, so that the correct columns are selected.

Furthermore, you can begin using `GeDi` with preprocessed example data based on the `r BiocStyle::Biocpkg("macrophage")` data. Simply click the <b>Load demo data</b> button to load the example data's enrichment results. You can also explore these results through the <b>Data preview</b> box on the right.

Upon successfully loading either your own data or the example data, two additional boxes will be displayed.

<b>Optional Filtering Step</b>: Filter generic genesets
The first new box is an <b>Optional Filtering Step</b>. While not mandatory for data exploration, this step can significantly enhance downstream processing runtime. In this step, you have the option to filter genesets in your data. Filtering out large and generic genesets can improve result interpretation. Alternatively, you can filter out genesets exceeding a certain size. 

The box displays a histogram illustrating geneset sizes and provides input fields for filtering. The left input field lets you select individual genesets by their identifiers in the "Genesets" column of your input. The right input field allows you to set a threshold "x" for filtering genesets with a size greater than or equal to "x."

<b>Step 2</b>: Species Selection
A second box labeled <b>Step 2</b> will open. Here, you can select the species associated with your data. This selection is vital for the <b>PMM score</b> in GeDi, which relies on a <b>Protein-Protein Interaction (PPI)</b> matrix. This matrix captures protein interaction strength, enhancing distance scores with biological context. To download this information, you must specify your data's species. Clicking the input field opens a dropdown with preselected species. If your species is included, choose it. If not, type it manually. If uncertain, follow the link on the right to the STRING database to verify species details and PPI availability.

<b>Step 3</b>: PPI Matrix Download
After species selection, a third box named <b>Step 3</b> will appear. In this step, you can download the PPI matrix. This process may take some time, with a progress bar in the lower right corner keeping you informed. Once downloaded, you can preview the PPI matrix in the <b>PPI Preview</b> box on the right.  As you see there, the PPI is build up of three columns: <b>Gene1</b> and <b>Gene2</b> which contain the gene symbols of the corresponding interacting proteins and a column <b>combined_score</b> which reflects the confidence of the interaction. The score is based on the number of known interactions between two proteins normalized to the (0, 1) interval through <math display="block"><mi>combined_score</mi><mo>=</mo><mfrac><mrow><mi>#interactions</mi><mo>-</mo><mi>min</mi></mrow> <mrow><mi>max</mi><mo>-</mo><mi>min</mi></mrow></mfrac></math> where <b>min</b> and <b>max</b> are the number of fewest and most interactions respectively.

The last two steps are optional, as the PPI matrix is required for only one score. You can already begin exploring your data even without completing these steps.

Upon finishing the necessary steps in this panel, you can proceed to the <b>Distance Scores</b> panel.

## The Distance Scores panel
This panel primarily handles the computation of distance scores for your input data. Similar to the previous panel, this one is also divided into two separate boxes.

**Calculating Distance Scores**
The upper box, labeled <b>Calculate distance scores for your genesets</b>, allows you to choose from different distance scores for computation. Here are the available options:

* **PMM Score**: This score integrates protein-protein interaction (PPI) data into the Meet-Min distance. The PPI-weighted Meet-Min (<b>PMM</b>) score is defined as <math display="block"><mi>PMM</mi><mo>=</mo><mi>min(PMM(A->B)</mi><mo>,</mo><mi>PMM(B->A))</mi></math>, where <math display="block"><mi>PMM(X->Y)</mi><mo>=</mo><mi>1</mi><mo>-</mo><mfrac><mrow><mi>|X</mi><mo>&#8745</mo><mn>Y|</mn></mrow><mrow><mn>min(|X|</mn><mo>,</mo><mi>|Y|)</mi></mrow></mfrac><mi><mo>-</mo></mi><mfrac><mrow><mi>&#945</mi></mrow><mrow><mn>min(|X|</mn><mo>,</mo><mi>|Y|)</mi></mrow></mfrac><mrow><mi>&#8721 <sub>x&#8946X-Y</sub></mi><mfrac><mrow><mi>w &#8721 <sub>y&#8946X&#8745Y</sub>PPI(x, y)</mi><mo>+</mo><mi>&#8721 <sub>y&#8946Y-X</sub>PPI(x, y)</mi></mrow><mrow><mn>max(PPI)</mn><mi>(w|X&#8745Y| + |Y - X|)</mi></mrow></mfrac></mrow></math>, and <math display="block"><mi>w</mi><mo>=</mo><mrow><mfrac><mrow><mi>min(|X|, |Y|)</mi></mrow><mrow><mn>|X|</mn><mo>+</mo><mi>|Y|</mi></mrow></mfrac></mrow></math>. <mi>&#945</mi> is a scaling factor between 0 and 1. The PPI matrix can be downloaded from the <b>Data Input</b> panel. More details can be found in the paper by Yoon et al.

* **Kappa Score**: The <b>Kappa</b> distance is a set-based metric based on observed and expected agreement rates between two genesets. It is defined as <math display="block"><mi>Kappa</mi><mo>=</mo><mi>1</mi><mo>-</mo><mfrac><mrow><mi>O</mi><mo>-</mo><mn>E</mn></mrow><mrow><mn>1</mn><mo>-</mo><mi>E</mi></mrow></mfrac></math>, where <math display="block"><mi>O</mi><mo>=</mo><mfrac><mrow><mi>|A&#8745B|</mi><mo>+</mo><mn>|(A&#8746B)<sup>c</sup>|</mn></mrow><mrow><mi>U</mi></mrow></mfrac></math> and <math display="block"><mi>E</mi><mo>=</mo><mfrac><mrow><mi>|A||B|</mi><mo>+</mo><mn>|A<sup>c</sup>||B<sup>c</sup>|</mn></mrow><mrow><mi>U<sup>2</sup></mi></mrow></mfrac></math> and U is the set of all unique genes in the data. In this application the Kappa distance is additionally normalized to the (0, 1) interval to make it comparable to the remaining distance metrics.

* **Jaccard Score**: The <b>Jaccard</b> distance uses the Jaccard coefficient, which is transformed into a distance metric by subtracting it from 1. It is defined as <math display="block"><mi>Jaccard</mi><mo>=</mo><mi>1</mi><mo>-</mo><mfrac><mrow><mi>|A</mi><mo>&#8745</mo><mn>B|</mn></mrow><mrow><mn>|A</mn><mo>&#8746</mo><mi>B|</mi></mrow></mfrac></math>.

* **Meet-Min Score**: The <b>Meet-Min</b> (MM) distance transforms the overlap coefficient into a distance measure by subtracting it from 1.The overlap coefficient is a similarity measure which is defined as <math display="block"><mi>OC</mi><mo>=</mo><mfrac><mrow><mi>|A</mi><mo>&#8745</mo><mn>B|</mn></mrow><mrow><mn>min(|A|</mn><mo>,</mo><mi>|B|)</mi></mrow></mfrac></math>. In order to transform this measure of similarity into a measure of distance, the overlap coefficient is substracted from 1, resulting in the calculation of the Meet-Min (MM) distance as <math display="block"><mi>MM</mi><mo>=</mo><mi>1</mi><mo>-</mo><mfrac><mrow><mi>|A</mi><mo>&#8745</mo><mn>B|</mn></mrow><mrow><mn>min(|A|</mn><mo>,</mo><mi>|B|)</mi></mrow></mfrac></math>. As a solely set based measurement, the Meet-Min distance only takes the composition of the genesets into account but not the underlying biological information inherent in the genesets.

Each score has its strengths and limitations, so it's essential to select one that aligns well with your data. Once you choose a score, the <b>Score the Genesets</b> button appears on the right, allowing you to initiate the scoring process. Keep in mind that this step might take some time, especially for larger datasets. Look for the progress bar in the lower right corner for updates on the scoring status.

After the scoring is complete, you can explore various visualizations of your data in the <b>Geneset Distance Scores</b> box.

**Distance Scores Visualizations**
**Distance Scores Heatmap**: The first visualization is a heatmap of distance scores. You need to initiate the heatmap calculation by clicking the <b>Calculate Distance Score Heatmap</b> button. After computation, you can interact with the heatmap. Hovering over it displays the involved genesets and calculated scores. You can also zoom in by selecting an area. To reset the zoomed view, click outside the heatmap area.

**Distance Scores Dendrogram**: The second visualization is a dendrogram of individual distance scores. The dendrogram is generated using hierarchical clustering, grouping the most similar genesets. The dropdown menu on the left allows you to select different combination methods, affecting the resulting dendrogram.

**Distance Scores Graph**: The last visualization is a graph representation of distance scores. Genesets with scores below a certain threshold are connected by edges. The default threshold is 0.3, adjustable via the slider on the left. The graph is interactive, allowing you to hover or click on nodes to highlight connected nodes. Additional information about genesets is displayed upon selection. Clicking on a geneset ID in the text field links to a relevant database for more information. You can also search for specific genesets using the input on the left. After selection, the geneset is highlighted in the graph. The <b>Graph metrics</b> box contains various metrics for the graph, such as degree, betweenness, harmonic centrality, clustering coefficient, and input data. This table provides insights into data and distance scores.

Once you've explored the distance scores, you can proceed to the <b>Clustering graph</b> panel.

## The Clustering Graph panel


This panel has as its main component an interactive bipartite graph illustrating the relationship between genesets and genes that belong to them.
One of the relevant parameters for this output is the number of gene sets to be displayed, adjustable from the widget in the control panel on the right.

Such a representation is particularly useful to see overlap between terms, and grasp the way how different genes may play a concerting role in different processes.

The color and shape of the nodes depend on the entity they are related to:

- genes are shown as ellipses, colored with a palette diverging from a neutral color to red (log2FC > 0) or to blue (log2FC < 0)
- gene sets are enclosed in gold boxes

The interactivity in this graph is essential for zooming, panning, and selecting its nodes.
The node selection, in particular, triggers a drill-down exploration, which populates a box on the right side, either with a signature heatmap (for a gene set), or with an expression plot, split by the experimental covariates of interest (for a gene) - this behavior can be controlled by the "Group/color by" selectize widget in the control sidebar.
In both cases, some HTML content is also generated, with buttons linking to external databases where to retrieve additional information (e.g. ENSEMBL, NCBI, AmiGO, ...).

A demonstration of how to use this panel effectively is provided by the tour, triggered by clicking on the question circle button (<i class="fa fa-question-circle"></i>) button in the upper right corner of the tab.

**Bookmarking from the Gene-Geneset panel:** When clicking on the Bookmark button while in this tab, it is possible to add to the shortlisted items of interest both genes and gene sets.
To do so, while one of the nodes is selected, click on the button with the mouse - or alternatively, click on the Left Ctrl button of your keyboard.
A notification will be triggered, informing the status of the bookmarked elements.

## The Enrichment Map panel

This panel, similar to the Gene-Geneset tab, has again an interactive graph of a subset of the gene sets (you can control again the number of included sets from the control sidebar).
This is also called an enrichment map - it is also possible to generate them in tools such as Cytoscape.
In this case, the genesets are directly connected by an edge, where the thickness encodes the degree of similarity (e.g. in terms of overlap) between them; sets below a similarity threshold are not displayed for the sake of better clarity.

The size of the node encodes the information of the number of genes detected as Differentially Expressed (from the column `gs_de_count`), while the color is representative of the computed Z score for each set.
This value is computed as $z = \frac{(upgenes - downgenes)}{\sqrt{(upgenes + downgenes)}}$ and is indicative of the expression changes of the genes assigned to a particular set.
Please, keep in mind that methods based on overrepresentation analysis only do not account for the topology that might be behind the set of interacting features (i.e. an upregulated gene involved in inhibition of a pathway would still be counted as a positive element in the equation above).

The `z_score` and `aggr_score` (in the simplest form, a mean of the log2FoldChange values for all the genes of a set) can be easily computed with the `get_aggrscores()`, which appends these scores for each gene set to the original `res_enrich` data frame.

The interactive flavor in this tab permits a quick exploration of the signature heatmaps for the genesets of interest by simply clicking on a node; this also triggers the display of some HTML content, if related to a Gene Ontology term.

A demonstration of how to use this panel effectively is provided by the tour, triggered by clicking on the question circle button (<i class="fa fa-question-circle"></i>) button in the upper right corner of the tab.

In the section below the interactive enrichment map, the functionality for the _distillation_ of gene sets into meta-genesets is provided.  
In brief, a community detection algorithm is run on the graph underlying the enrichment map, and the additional information extracted is rendered as a table, linked to a meta-geneset box to display the expression signature for all its member genes.

**Bookmarking from the Enrichment Map panel:** If the user clicks on the Bookmark button while in this tab, it will add the selected node to the shortlist of genesets, visible later in the Bookmarks panel.
The Left Ctrl button of your keyboard can again be used for this purpose, and this will trigger a notification in the lower right part of the screen.

## The Overview panel

This panel presents to the user a series of summary plots, based on the outputs of `enhance_table()` and `gs_volcano()`, aiming to provide a mean to summarize the most relevant genesets in the `res_enrich` object.
The number of displayed (or labeled, according to each function) genesets can be as usual controlled by the widget in the right sidebar.

We avoid (re)rendering all plots at once by placing them as content of different tabs in a `bs4TabCard` container - this allows the user to navigate in a more agile way to the desired output elements.

Interactive versions of the plots are returned via calls to `ggplotly`.

A demonstration of how to use this panel effectively is provided by the tour, triggered by clicking on the question circle button (<i class="fa fa-question-circle"></i>) button in the upper right corner of the tab.

## The GSViz panel

This panel, similarly to the Overview panel, presents a variety of plots visualizing the gene sets - and their mutual relationships, or their behavior across samples.
This includes, for example:

- a genesets by sample heatmap (via `gs_scores()` and `gs_scoresheat()`),  with a score for each matrix element corresponding to the sum of the standardized expression values of its components
- a genesets-gene Sankey diagram (via `gs_alluvial()`, aliased to `gs_sankey()`), to represent the N:N membership relationships
- a summary heatmap (via `gs_summary_heat()`) to display the memberships and at the same time the expression change of each gene set member
- a multi-dimensional scaling (MDS) plot, based on `gs_mds()`, to provide a 2d visualization of the distance among genesets (based on a similarity measure e.g. their overlap or other criteria, such as their semantic similarity)
- a compact summary of `res_enrich`, via `gs_summary_overview()`, where aggregated scores and significance can be displayed on the same plot - for this, there are functions to compare different `res_enrich` objects (`gs_summary_overview()`, `gs_summary_overview_pair()`)
- alternative visual representation of the `res_enrich` objects, based on `gs_radar()` (equivalent to `gs_spider()`) and `gs_dendro()`

As in many other panels, the control over the number of genesets displayed is tweaked with the widget in the right sidebar, "Number of genesets".

A demonstration of how to use this panel effectively is provided by the tour, triggered by clicking on the question circle button (<i class="fa fa-question-circle"></i>) button in the upper right corner of the tab.

## The Bookmarks panel

In this panel, the user can obtain a complete overview on the bookmarked features of interest, both genes (left side) and genesets (right side). 

During a live exploration session, it might be tricky to recall the exact aspect of each point of interest. 

Below the interactive `DT::datatable` objects, the content of each table can also be separately downloaded by clicking on the respective button.
Moreover, there is a button (with the cocktail icon <i class="fa fa-cocktail"></i>) that triggers the generation of a content-rich report which will focus on all the shortlisted elements.
This leverages a template report delivered as a part of `r BiocStyle::Biocpkg("GeneTonic")`, which accesses the input elements and the reactive values for the bookmarks, based on the `happy_hour()` function.

If a user already knows a set of features and geneset of interest, it is also possible to practically call `happy_hour()` directly from the command line (see the example in the chunk below).
Please keep in mind that the identifiers to be used should match the values used as row names of the `dds` object and as `gs_id` column of the original `res_enrich` input.

This report will serve as a useful means to generate a permanent and reproducible analysis output, that can be further stored or shared.

Ideally, each live session with `GeneTonic` could terminate with a call to `happy_hour()` - admittedly, an aperitivo should start with that, and not end - please accept our apologies :) .

A demonstration of how to use this panel effectively is provided by the tour, triggered by clicking on the question circle button (<i class="fa fa-question-circle"></i>) button in the upper right corner of the tab.

In this panel, an export button to a `SummarizedExperiment` object to be provided as input to the `r BiocStyle::Biocpkg("iSEE")` package has been added in version >= 1.2.0. 
This enables further and fine-grained visualization options in the `iSEE` framework -  if the flavors of `GeneTonic` are not yet what you would want, you might find an excellent venue there.

# Using the `GeneTonic` functions {#functions}

The `r BiocStyle::Biocpkg("GeneTonic")` package provides, apart from the main app where to perform the analysis in an interactive way, a number of functions which can be used also as standalone components for a workflow.

This sections contains some showcase examples on how to use them.

## Overview functions: genes and gene sets

Summarize the top genesets by displaying the logFC of each set's components - and transform the `ggplot` output into a `plotly` visualization, where tooltips can deliver additional information:

Display the relationship between genesets and genes that belong to them (useful e.g. to see overlap between terms):

Display a bipartite graph where genesets and genes are included, and make it interactive:

## Summary representations

Plot an enrichment map of the enrichment results, where you can choose with `n_gs` the number of top genesets to be displayed, and specify in `gs_ids` the gene set identifiers - these will be merged together for each function's context:

Expanding on the enrichment map, the distilled content of the `res_enrich` can be represented as enhanced tables and interactive graphs, depicting the membership of the respective meta-genesets


Another possibility to summarize the result of enrichment is by applying fuzzy clustering on it to detect groups of related genesets, with the peculiarity that a geneset can belong to different clusters - this reflects the original implementation of DAVID [@Huang2009].  
The `gs_fuzzyclustering()` function returns a table with additional columns, related to the cluster id and the status for the geneset in that cluster ("Representative" or "Member", where the Representative geneset is the one with lowest p-value in that cluster).


Display a volcano plot for genesets, plotting significance (y-axis) versus Z score (x-axis), with color and size encoding some geneset features:


Plot a dendrogram of the enrichment results (or a subset thereof), using node color, node size, and branch color to encode relevant geneset features (and their groups):

Produce a MultiDimensional Scaling plot of the genesets in the enrichment results:


Obtain a simple overview of enrichment results, showing e.g. significance and direction of change (`z_score`)


Plot a summary heatmap of genes vs genesets, encoding the logFC of genes and representing the overlap among genesets:


Recalling that you can also use a `gtl` list object as input, a similar call would be:



Plot a heatmap on the geneset scores, computed sample-wise via `gs_scores` so that the geneset members compose a Z score that gets summarized: 


## Reporting

Enjoy a fully fledged `happy_hour` by running offline the analysis contained in the report, included in the `r BiocStyle::Biocpkg("GeneTonic")` package.


Again, if used with the `gtl` object, the call would look like this:


The functionality is also the same activated in the Bookmarks section of the interactive app.
Here you can choose a number of genesets (`mygenesets`) and genes (`mygenes`), specifying their identifiers, and obtain in batch a number of summary representations focused on these elements.

Advanced users can also provide a custom RMarkdown file, and to guarantee it works in the context of `happy_hour`, we recommend to inspect the template available here:


## Comparison between sets

While `GeneTonic` works currently with a single `res_enrich` object, there are some functions that allow a visual comparison between two different enrichment results (the functions are displaying a shuffled instance of the single `res_enrich`):

In particular, the `gs_horizon` function tries to group the different genesets based on their relative enrichment across conditions, similar to a representation of [@Dutertre2019] (e.g. Fig. 5G).
Thanks to Charlotte Soneson for providing a compact working implementation of this!

## Miscellaneous functions

Extract results and sort them (filtering by FDR) with `deseqresult2df`, select one top-ranking gene, extract its expression values and plot them, and display some buttons to link to external databases:


Plot a signature heatmap for a gene set, where a matrix of genes times samples for the set members is extracted, plus generate some HTML code to summarize the information of a Gene Ontology term:


Plot a signature volcano plot for a gene set, with the genes of the geneset highlighted in color and the remaining genes shown shaded in the background: 


Some functions are just to ensure that the input objects are conform with the format expected by `GeneTonic`:


As an internal check, one can see if all required arguments are fine for running `GeneTonic` by running `checkup_GeneTonic`:



# Additional Information {#additionalinfo}

Bug reports can be posted on the Bioconductor support site (https://support.bioconductor.org/) or raised as issues in the `GeDi` GitHub repository (https://github.com/AnnekathrinSilvia/GeDi/issues). 
The GitHub repository also contains the development version of the package, where new functionality is added over time - careful, you might be running bleeding edge versions!

The authors appreciate well-considered suggestions for improvements or new features, or even better, pull requests.

If you use `GeDi` for your analysis, please cite it as shown below:

```{r citation}
utils::citation("GeDi")
```

# Additional example data

As a tool to support the exploration of various enrichment results, `GeDi` does not also support results from the `r BiocStyle::Biocpkg("topGO")` package, but also other packages for enrichment analysis as e.g. `r BiocStyle::Biocpkg("clusterProfiler")`. In this section, we will show you how to prepare the results of `clusterProfiler` for the usage in `GeDi` as well as how to use functional annotations against the KEGG and Reactome database. 

As a basis we will again use the data of the `r BiocStyle::Biocpkg("macrophage")` package, specifically the differentially expressed genes we have identified before. 

However, before we can use the `enrichKEGG` function from the `r BiocStyle::Biocpkg("clusterProfiler")` package, we have to amp the ENSEMBL ids of the data to Entrez ids. For this, we will up the first use the `r BiocStyle::Biocpkg("biomaRt")` package to generate a mapping of ENSEMBL to Entrez.

```{r}
library("biomaRt")
mart <-
  useMart(biomart = "ENSEMBL_MART_ENSEMBL", dataset = "hsapiens_gene_ensembl")
anns <- getBM(
  attributes = c(
    "ensembl_gene_id",
    "external_gene_name",
    "entrezgene_id",
    "description"
  ),
  filters = "ensembl_gene_id",
  values = rownames(dds_macrophage),
  mart = mart
)
anns <- anns[match(rownames(dds_macrophage), anns[, 1]), ]
```

Next, we map the differentially expressed genes to get the right identifiers and run the `enrichKEGG` function. We set the organism to human and the p-value cutoff to 5%.

```{r enrichKegg}
library("clusterProfiler")
genes <- anns$entrezgene_id[match(rownames(res_macrophage_IFNg_vs_naive), anns$ensembl_gene_id)]

res_enrich <- enrichKEGG(genes,
  organism = "hsa",
  pvalueCutoff = 0.05
)
```

We can now use the results of the enrichment in `GeDi`. For this, we can either save the results and provide them to a running instance of `GeDi` or we can provided it directly as an input to the app. 

```{r GeDi_Kegg, eval = F}
saveRDS(res_enrich@result, "macrophage_KEGG_example.RDS")

# start an instance of GeDi and provide the macrophage_KEGG_example.RDS file
GeDi()

# start GeDi directly with the data loaded
GeDi(genesets = res_enrich@result)
```

In a similar manner we can use the Reactome database for the functional annotation. Here, we use the 
`r BiocStyle::Biocpkg("ReactomePA")` package and the differentially expressed genes. 

```{r enrichReactome}
library("ReactomePA")
reactome <- enrichPathway(genes,
  organism = "human",
  pvalueCutoff = 0.05,
  readable = TRUE
)
```

Now we can use the results in the same manner as for the KEGG pathway analysis. 

```{r GeDi_Reactome, eval = F}
saveRDS(reactome@result, "macrophage_Reactome_example.RDS")

# start an instance of GeDi and provide the macrophage_KEGG_example.RDS file
GeDi()

# start GeDi directly with the data loaded
GeDi(genesets = reactome@result)
```


# FAQs {#faqs}

**Q: My configuration on two machines is somewhat different, so I am having difficulty in finding out what packages are different. Is there something to help on this?**

A: Yes, you can check out `r BiocStyle::Githubpkg("federicomarini/sessionDiffo")`, a small utility to compare the outputs of two different `sessionInfo` outputs.
This can help you pinpoint what packages might be causing the issue.

**Q: I am using a different service/software for generating the results of functional enrichment analysis. How do I plug this into `GeneTonic`?**

A: You can set up a small conversion function, on the line of `shake_topGOtableResult` and `shake_enrichResult` (*use the source, Luke* to see how you can build your own), or request such a function - make sure to specify the formatting specifications of your tool of choice (e.g. DAVID, g:Profiler, or commercial solutions such as Ingenuity Pathway Analysis).  
As of Bioconductor release 3.12 (version >= 1.2.0 for `r BiocStyle::Biocpkg("GeneTonic")`), shaker functions are available for these tools:

- `DAVID` (https://david.ncifcrf.gov/), with the result exported in text format
- `topGO` (available in the `r BiocStyle::Biocpkg("topGO")` package), as in the wrapper function provided by `r BiocStyle::Biocpkg("pcaExplorer")`, `pcaExplorer::topGOtable()`
- `Enrichr` (https://amp.pharm.mssm.edu/Enrichr/), either from text format or from a call via the `r BiocStyle::CRANpkg("enrichr")` package
- `fgsea`, taking the output of the workflow from the `r BiocStyle::Biocpkg("fgsea")` package
- `g:Profiler` (https://biit.cs.ut.ee/gprofiler/), either from text file format or with the output of `gost()` in `r BiocStyle::CRANpkg("gprofiler2")`
- `clusterProfiler`, providing `enrichResult` objects, commonly returned by `enrichGO()` from `r BiocStyle::Biocpkg("clusterProfiler")` or `enrichPathway()` from `r BiocStyle::Biocpkg("ReactomePA")`

**Q: I'd like to try `GeneTonic` but I could not install it/I just want a quick peek into it. What can I do for this?**

A: We set up an instance of `GeneTonic` running on the `macrophage` dataset at this address: http://shiny.imbei.uni-mainz.de:3838/GeneTonic.

# Session Info {- .smaller}

```{r sessioninfo}
utils::sessionInfo()
```

# References {-}
